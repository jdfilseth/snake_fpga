
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module snake(

	//////////// CLOCK //////////
	input 		          		ADC_CLK_10,
	input 		          		MAX10_CLK1_50, // only input clock used (50MHz)
	input 		          		MAX10_CLK2_50,

	//////////// SEG7 //////////
	output		     [7:0]		HEX0,
	output		     [7:0]		HEX1,
	output		     [7:0]		HEX2,
	output		     [7:0]		HEX3,
	output		     [7:0]		HEX4,
	output		     [7:0]		HEX5,

	//////////// KEY //////////
	input 		     [1:0]		KEY,

	//////////// VGA //////////
	output		     [3:0]		VGA_B,
	output		     [3:0]		VGA_G,
	output		          		VGA_HS,
	output		     [3:0]		VGA_R,
	output		          		VGA_VS,

	//////////// Accelerometer //////////
	output		          		GSENSOR_CS_N,
	input 		     [2:1]		GSENSOR_INT,
	output		          		GSENSOR_SCLK,
	inout 		          		GSENSOR_SDI,
	inout 		          		GSENSOR_SDO
);


`include "v/game_vga_param.h"	 

//=======================================================
//  REG/WIRE declarations
//=======================================================

wire vga_ctrl_clk; // clock for VGA (25MHz)
wire game_clk; // main clock (10MHz)
wire is_over; // 1 = game over, 0 = not game over; sent to VGA module
wire is_start_screen; // 1 = start screen, 0 = not start screen; sent to VGA module
wire [BOARD_WIDTH*BOARD_HEIGHT*3-1:0] board_state; // carries board information for VGA to output
wire [10:0] score; // sends score to hex segments

// for SPI/accelerometer
wire	        dly_rst;
wire	        spi_clk, spi_clk_out;
wire	[15:0]  data_x;
wire 	[15:0]	data_y;

// direction variable
wire [2:0] direction;

// random board position for generating new dots
wire [BOARD_WIDTH_BITS:0] 		rand_x;
wire [BOARD_HEIGHT_BITS:0]		rand_y;


//=======================================================
//  Structural coding
//=======================================================

// 10MHz (game) and 25MHz (VGA) PLL
// VGA is supposed to be 25.175MHz but 25MHz displays fine and achieves timing closure
vga_pll u_vga_pll(
	.areset(),
	.inclk0(MAX10_CLK1_50),
	.c0(vga_ctrl_clk), // 25MHz
	.c1(game_clk), // 10MHz
	.locked());

// reset_delay for GSensor
reset_delay	u_reset_delay	(	
            .iRSTN(KEY[0]),
            .iCLK(vga_ctrl_clk),
            .oRST(dly_rst));

// 2MHz and 2MHz w/ 270 degree phase shift PLL for GSensor
spi_pll     u_spi_pll	(
            .areset(dly_rst),
            .inclk0(MAX10_CLK1_50),
            .c0(spi_clk),      // 2MHz
            .c1(spi_clk_out)); // 2MHz phase shift 

// random number generator
rng			rng_1 (
	.clk(game_clk),
	.reset(KEY[0]),
	.rand_x(rand_x),
	.rand_y(rand_y)
);

// Main module
main_game mg_1(
	.hard_reset(KEY[0]),
	.game_reset(KEY[1]),
	.clk(game_clk),
	.rand_x(rand_x),
	.rand_y(rand_y),
	.input_direction(direction),
	.board_state(board_state),
	.is_start_screen(is_start_screen),
	.is_over(is_over),
	.score(score)
);

//  Initial Setting and Data Read Back
spi_ee_config u_spi_ee_config (			
						.iRSTN(!dly_rst),															
						.iSPI_CLK(spi_clk),								
						.iSPI_CLK_OUT(spi_clk_out),								
						.iG_INT2(GSENSOR_INT[1]),            
						.xDATA_L(data_x[7:0]),
						.xDATA_H(data_x[15:8]),
						.yDATA_L(data_y[7:0]),
						.yDATA_H(data_y[15:8]),
						.SPI_SDIO(GSENSOR_SDI),
						.oSPI_CSN(GSENSOR_CS_N),
						.oSPI_CLK(GSENSOR_SCLK));
		
// generate direction from G-sensor reading		
assign_direction ad_1 (
	.input_x(data_x[9:0]),
	.input_y(data_y[9:0]),
	.direction(direction)
);

// VGA output module
vga_controller vga_ins(.vga_reset(KEY[0]),
                      .vga_clk(vga_ctrl_clk),
					  .board_state(board_state),
					  .is_start_screen(is_start_screen),
					  .is_over(is_over),
                      .oHS(VGA_HS),
                      .oVS(VGA_VS),
                      .oVGA_B(VGA_B),
                      .oVGA_G(VGA_G),
                      .oVGA_R(VGA_R));	
					  
					  
// Hex score output module
score_counter sc_1(
	.score(score),
	.hex0(HEX0),
	.hex1(HEX1),
	.hex2(HEX2),
	.hex3(HEX3),
	.hex4(HEX4),
	.hex5(HEX5)
);

endmodule
